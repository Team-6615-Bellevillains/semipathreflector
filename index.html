<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Reflection Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 1px solid #ccc;
            margin: 20px 0;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .color-box {
            width: 20px;
            height: 20px;
        }
        .input-section {
            margin-bottom: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Path Reflection over y = 4.026</h1>
        
        <div class="input-section">
            <p>Upload a path file:</p>
            <input type="file" id="fileInput" accept=".path,.txt">
        </div>
        
        <div class="legend" id="legend" style="display: none;">
            <div class="legend-item">
                <div class="color-box" style="background-color: blue;"></div>
                <span>Original Path</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: red;"></div>
                <span>Reflected Path</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: green;"></div>
                <span>Reflection Line (y = 4.026)</span>
            </div>
        </div>
        
        <canvas id="pathCanvas" width="800" height="600" style="display: none;"></canvas>
        
        <div id="waypoints-info" style="display: none; width: 100%; max-width: 800px;">
            <div id="original-waypoints"></div>
            <div id="reflected-waypoints"></div>
            
            <h3>Reflected Path JSON:</h3>
            <pre id="json-output" style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; max-width: 100%;"></pre>
            <button id="copy-button" style="margin-top: 10px; padding: 5px 10px;">Copy JSON</button>
        </div>
    </div>

    <script>
        // Get elements
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('pathCanvas');
        const legend = document.getElementById('legend');
        const waypointsInfo = document.getElementById('waypoints-info');
        const originalWaypointsDiv = document.getElementById('original-waypoints');
        const reflectedWaypointsDiv = document.getElementById('reflected-waypoints');
        
        // The reflection line value
        const reflectionLine = 8.052 / 2; // = 4.026
        
        // Add event listener to file input
        fileInput.addEventListener('change', handleFileSelect);
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            
            if (!file) {
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const pathData = JSON.parse(e.target.result);
                    processPathData(pathData);
                } catch (error) {
                    alert('Error parsing file: ' + error.message);
                    console.error('Error parsing file:', error);
                }
            };
            
            reader.onerror = function() {
                alert('Error reading file');
            };
            
            reader.readAsText(file);
        }
        
        // Function to reflect a point over the line y = reflectionLine
        function reflectPoint(point) {
            if (!point) return null;
            
            return {
                x: point.x,
                y: 2 * reflectionLine - point.y
            };
        }
        
        // Function to reflect a rotation angle (add 180 degrees)
        function reflectRotation(angle) {
            if (angle === undefined || angle === null) return angle;
            return (angle + 180) % 360;
        }
        
        function processPathData(pathData) {
            // Validate data
            if (!pathData.waypoints || !Array.isArray(pathData.waypoints)) {
                alert('Invalid path data: waypoints array not found');
                return;
            }
            
            // Create reflected waypoints
            const reflectedWaypoints = pathData.waypoints.map(waypoint => {
                return {
                    anchor: reflectPoint(waypoint.anchor),
                    prevControl: reflectPoint(waypoint.prevControl),
                    nextControl: reflectPoint(waypoint.nextControl),
                    isLocked: waypoint.isLocked,
                    linkedName: waypoint.linkedName
                };
            });
            
            // Create a complete reflected path object
            const reflectedPathData = JSON.parse(JSON.stringify(pathData));
            reflectedPathData.waypoints = reflectedWaypoints;
            
            // Reflect rotation values
            if (reflectedPathData.goalEndState && reflectedPathData.goalEndState.rotation !== undefined) {
                reflectedPathData.goalEndState.rotation = reflectRotation(reflectedPathData.goalEndState.rotation);
            }
            
            if (reflectedPathData.idealStartingState && reflectedPathData.idealStartingState.rotation !== undefined) {
                reflectedPathData.idealStartingState.rotation = reflectRotation(reflectedPathData.idealStartingState.rotation);
            }
            
            // Display the JSON output
            const jsonOutput = document.getElementById('json-output');
            jsonOutput.textContent = JSON.stringify(reflectedPathData, null, 2);
            
            // Set up copy button
            const copyButton = document.getElementById('copy-button');
            copyButton.addEventListener('click', () => {
                navigator.clipboard.writeText(JSON.stringify(reflectedPathData, null, 2))
                    .then(() => {
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => {
                            copyButton.textContent = 'Copy JSON';
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy text: ', err);
                        copyButton.textContent = 'Copy failed';
                        setTimeout(() => {
                            copyButton.textContent = 'Copy JSON';
                        }, 2000);
                    });
            });
            
            // Display waypoints info
            displayWaypointsInfo(pathData.waypoints, reflectedWaypoints);
            
            // Draw paths
            drawPaths(pathData.waypoints, reflectedWaypoints);
            
            // Show elements
            canvas.style.display = 'block';
            legend.style.display = 'flex';
            waypointsInfo.style.display = 'block';
        }
        
        function displayWaypointsInfo(originalWaypoints, reflectedWaypoints) {
            // Clear previous content
            originalWaypointsDiv.innerHTML = '<h3>Original Waypoints:</h3>';
            reflectedWaypointsDiv.innerHTML = '<h3>Reflected Waypoints:</h3>';
            
            // Add original waypoints
            const originalList = document.createElement('ul');
            originalWaypoints.forEach((waypoint, index) => {
                const item = document.createElement('li');
                item.textContent = `Waypoint ${index + 1}: (${waypoint.anchor.x.toFixed(3)}, ${waypoint.anchor.y.toFixed(3)})`;
                originalList.appendChild(item);
            });
            originalWaypointsDiv.appendChild(originalList);
            
            // Add reflected waypoints
            const reflectedList = document.createElement('ul');
            reflectedWaypoints.forEach((waypoint, index) => {
                const item = document.createElement('li');
                item.textContent = `Waypoint ${index + 1}: (${waypoint.anchor.x.toFixed(3)}, ${waypoint.anchor.y.toFixed(3)})`;
                reflectedList.appendChild(item);
            });
            reflectedWaypointsDiv.appendChild(reflectedList);
        }
        
        function drawPaths(originalWaypoints, reflectedWaypoints) {
            const ctx = canvas.getContext('2d');
            
            // Find the bounds of all points for scaling
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            // Function to update bounds based on a point
            function updateBounds(point) {
                if (point) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }
            }
            
            // Check original waypoints
            originalWaypoints.forEach(waypoint => {
                updateBounds(waypoint.anchor);
                updateBounds(waypoint.prevControl);
                updateBounds(waypoint.nextControl);
            });
            
            // Check reflected waypoints
            reflectedWaypoints.forEach(waypoint => {
                updateBounds(waypoint.anchor);
                updateBounds(waypoint.prevControl);
                updateBounds(waypoint.nextControl);
            });
            
            // Add padding
            const padding = 50;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // Calculate scale factors
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            const scaleX = width / rangeX;
            const scaleY = height / rangeY;
            const scale = Math.min(scaleX, scaleY);
            
            // Function to convert real coordinates to canvas coordinates
            function toCanvasCoords(point) {
                return {
                    x: padding + (point.x - minX) * scale,
                    y: canvas.height - padding - (point.y - minY) * scale // Flip Y-axis
                };
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the reflection line
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding - (reflectionLine - minY) * scale);
            ctx.lineTo(canvas.width - padding, canvas.height - padding - (reflectionLine - minY) * scale);
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Label the reflection line
            ctx.fillStyle = 'green';
            ctx.font = '12px Arial';
            ctx.fillText(`y = ${reflectionLine.toFixed(3)}`, canvas.width - padding - 100, canvas.height - padding - (reflectionLine - minY) * scale - 5);
            
            // Function to draw a path
            function drawPath(waypoints, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // Draw the bezier curve path
                ctx.beginPath();
                
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const startPoint = toCanvasCoords(waypoints[i].anchor);
                    const endPoint = toCanvasCoords(waypoints[i + 1].anchor);
                    
                    if (waypoints[i].nextControl && waypoints[i + 1].prevControl) {
                        const control1 = toCanvasCoords(waypoints[i].nextControl);
                        const control2 = toCanvasCoords(waypoints[i + 1].prevControl);
                        
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.bezierCurveTo(control1.x, control1.y, control2.x, control2.y, endPoint.x, endPoint.y);
                    } else {
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(endPoint.x, endPoint.y);
                    }
                }
                
                ctx.stroke();
                
                // Draw the waypoints
                waypoints.forEach(waypoint => {
                    if (waypoint.anchor) {
                        const point = toCanvasCoords(waypoint.anchor);
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                    
                    // Draw control points and handles
                    if (waypoint.prevControl) {
                        const controlPoint = toCanvasCoords(waypoint.prevControl);
                        ctx.beginPath();
                        ctx.arc(controlPoint.x, controlPoint.y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.5;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                        
                        if (waypoint.anchor) {
                            const anchorPoint = toCanvasCoords(waypoint.anchor);
                            ctx.beginPath();
                            ctx.moveTo(anchorPoint.x, anchorPoint.y);
                            ctx.lineTo(controlPoint.x, controlPoint.y);
                            ctx.strokeStyle = color;
                            ctx.globalAlpha = 0.3;
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                    
                    if (waypoint.nextControl) {
                        const controlPoint = toCanvasCoords(waypoint.nextControl);
                        ctx.beginPath();
                        ctx.arc(controlPoint.x, controlPoint.y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.5;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                        
                        if (waypoint.anchor) {
                            const anchorPoint = toCanvasCoords(waypoint.anchor);
                            ctx.beginPath();
                            ctx.moveTo(anchorPoint.x, anchorPoint.y);
                            ctx.lineTo(controlPoint.x, controlPoint.y);
                            ctx.strokeStyle = color;
                            ctx.globalAlpha = 0.3;
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                });
            }
            
            // Draw coordinate axes
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(padding, padding);
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw tick marks and labels
            ctx.fillStyle = '#888';
            ctx.font = '10px Arial';
            
            // X-axis ticks
            for (let x = Math.ceil(minX); x <= Math.floor(maxX); x++) {
                const tickX = padding + (x - minX) * scale;
                ctx.beginPath();
                ctx.moveTo(tickX, canvas.height - padding);
                ctx.lineTo(tickX, canvas.height - padding + 5);
                ctx.stroke();
                ctx.fillText(x.toString(), tickX - 3, canvas.height - padding + 15);
            }
            
            // Y-axis ticks
            for (let y = Math.ceil(minY); y <= Math.floor(maxY); y++) {
                const tickY = canvas.height - padding - (y - minY) * scale;
                ctx.beginPath();
                ctx.moveTo(padding, tickY);
                ctx.lineTo(padding - 5, tickY);
                ctx.stroke();
                ctx.fillText(y.toString(), padding - 25, tickY + 3);
            }
            
            // Draw the original path
            drawPath(originalWaypoints, 'blue');
            
            // Draw the reflected path
            drawPath(reflectedWaypoints, 'red');
        }
    </script>
</body>
</html>